{"ast":null,"code":"import { isObject, isDate, isArray } from '../fns.js';\nimport fns from './helpers.js';\nconst {\n  parseArray,\n  parseObject,\n  parseNumber\n} = fns;\nimport namedDates from './named-dates.js';\nimport normalize from './normalize.js';\nimport parseString from './parse.js';\n//we have to actually parse these inputs ourselves\n//  -  can't use built-in js parser ;(\n//=========================================\n// ISO Date\t  \"2015-03-25\"\n// Short Date\t\"03/25/2015\" or \"2015/03/25\"\n// Long Date\t\"Mar 25 2015\" or \"25 Mar 2015\"\n// Full Date\t\"Wednesday March 25 2015\"\n//=========================================\n\nconst defaults = {\n  year: new Date().getFullYear(),\n  month: 0,\n  date: 1\n};\n\n//find the epoch from different input styles\nconst parseInput = (s, input) => {\n  let today = s._today || defaults;\n  //if we've been given a epoch number, it's easy\n  if (typeof input === 'number') {\n    return parseNumber(s, input);\n  }\n  //set tmp time\n  s.epoch = Date.now();\n  // overwrite tmp time with 'today' value, if exists\n  if (s._today && isObject(s._today) && Object.keys(s._today).length > 0) {\n    let res = parseObject(s, today, defaults);\n    if (res.isValid()) {\n      s.epoch = res.epoch;\n    }\n  }\n  // null input means 'now'\n  if (input === null || input === undefined || input === '') {\n    return s; //k, we're good.\n  }\n  //support input of Date() object\n  if (isDate(input) === true) {\n    s.epoch = input.getTime();\n    return s;\n  }\n  //support [2016, 03, 01] format\n  if (isArray(input) === true) {\n    s = parseArray(s, input, today);\n    return s;\n  }\n  //support {year:2016, month:3} format\n  if (isObject(input) === true) {\n    //support spacetime object as input\n    if (input.epoch) {\n      s.epoch = input.epoch;\n      s.tz = input.tz;\n      return s;\n    }\n    s = parseObject(s, input, today);\n    return s;\n  }\n  //input as a string..\n  if (typeof input !== 'string') {\n    return s;\n  }\n  //little cleanup..\n  input = normalize(input);\n  //try some known-words, like 'now'\n  if (namedDates.hasOwnProperty(input) === true) {\n    s = namedDates[input](s);\n    return s;\n  }\n  //try each text-parse template, use the first good result\n  return parseString(s, input);\n};\nexport default parseInput;","map":{"version":3,"names":["isObject","isDate","isArray","fns","parseArray","parseObject","parseNumber","namedDates","normalize","parseString","defaults","year","Date","getFullYear","month","date","parseInput","s","input","today","_today","epoch","now","Object","keys","length","res","isValid","undefined","getTime","tz","hasOwnProperty"],"sources":["/Users/lasagna/DecentralVote/DecentralVote/node_modules/spacetime/src/input/index.js"],"sourcesContent":["import { isObject, isDate, isArray } from '../fns.js'\nimport fns from './helpers.js'\nconst { parseArray, parseObject, parseNumber } = fns\nimport namedDates from './named-dates.js'\nimport normalize from './normalize.js'\nimport parseString from './parse.js'\n//we have to actually parse these inputs ourselves\n//  -  can't use built-in js parser ;(\n//=========================================\n// ISO Date\t  \"2015-03-25\"\n// Short Date\t\"03/25/2015\" or \"2015/03/25\"\n// Long Date\t\"Mar 25 2015\" or \"25 Mar 2015\"\n// Full Date\t\"Wednesday March 25 2015\"\n//=========================================\n\nconst defaults = {\n  year: new Date().getFullYear(),\n  month: 0,\n  date: 1\n}\n\n//find the epoch from different input styles\nconst parseInput = (s, input) => {\n  let today = s._today || defaults\n  //if we've been given a epoch number, it's easy\n  if (typeof input === 'number') {\n    return parseNumber(s, input)\n  }\n  //set tmp time\n  s.epoch = Date.now()\n  // overwrite tmp time with 'today' value, if exists\n  if (s._today && isObject(s._today) && Object.keys(s._today).length > 0) {\n    let res = parseObject(s, today, defaults)\n    if (res.isValid()) {\n      s.epoch = res.epoch\n    }\n  }\n  // null input means 'now'\n  if (input === null || input === undefined || input === '') {\n    return s //k, we're good.\n  }\n  //support input of Date() object\n  if (isDate(input) === true) {\n    s.epoch = input.getTime()\n    return s\n  }\n  //support [2016, 03, 01] format\n  if (isArray(input) === true) {\n    s = parseArray(s, input, today)\n    return s\n  }\n  //support {year:2016, month:3} format\n  if (isObject(input) === true) {\n    //support spacetime object as input\n    if (input.epoch) {\n      s.epoch = input.epoch\n      s.tz = input.tz\n      return s\n    }\n    s = parseObject(s, input, today)\n    return s\n  }\n  //input as a string..\n  if (typeof input !== 'string') {\n    return s\n  }\n  //little cleanup..\n  input = normalize(input)\n  //try some known-words, like 'now'\n  if (namedDates.hasOwnProperty(input) === true) {\n    s = namedDates[input](s)\n    return s\n  }\n  //try each text-parse template, use the first good result\n  return parseString(s, input)\n}\nexport default parseInput\n"],"mappings":"AAAA,SAASA,QAAQ,EAAEC,MAAM,EAAEC,OAAO,QAAQ,WAAW;AACrD,OAAOC,GAAG,MAAM,cAAc;AAC9B,MAAM;EAAEC,UAAU;EAAEC,WAAW;EAAEC;AAAY,CAAC,GAAGH,GAAG;AACpD,OAAOI,UAAU,MAAM,kBAAkB;AACzC,OAAOC,SAAS,MAAM,gBAAgB;AACtC,OAAOC,WAAW,MAAM,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMC,QAAQ,GAAG;EACfC,IAAI,EAAE,IAAIC,IAAI,CAAC,CAAC,CAACC,WAAW,CAAC,CAAC;EAC9BC,KAAK,EAAE,CAAC;EACRC,IAAI,EAAE;AACR,CAAC;;AAED;AACA,MAAMC,UAAU,GAAGA,CAACC,CAAC,EAAEC,KAAK,KAAK;EAC/B,IAAIC,KAAK,GAAGF,CAAC,CAACG,MAAM,IAAIV,QAAQ;EAChC;EACA,IAAI,OAAOQ,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOZ,WAAW,CAACW,CAAC,EAAEC,KAAK,CAAC;EAC9B;EACA;EACAD,CAAC,CAACI,KAAK,GAAGT,IAAI,CAACU,GAAG,CAAC,CAAC;EACpB;EACA,IAAIL,CAAC,CAACG,MAAM,IAAIpB,QAAQ,CAACiB,CAAC,CAACG,MAAM,CAAC,IAAIG,MAAM,CAACC,IAAI,CAACP,CAAC,CAACG,MAAM,CAAC,CAACK,MAAM,GAAG,CAAC,EAAE;IACtE,IAAIC,GAAG,GAAGrB,WAAW,CAACY,CAAC,EAAEE,KAAK,EAAET,QAAQ,CAAC;IACzC,IAAIgB,GAAG,CAACC,OAAO,CAAC,CAAC,EAAE;MACjBV,CAAC,CAACI,KAAK,GAAGK,GAAG,CAACL,KAAK;IACrB;EACF;EACA;EACA,IAAIH,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAKU,SAAS,IAAIV,KAAK,KAAK,EAAE,EAAE;IACzD,OAAOD,CAAC,EAAC;EACX;EACA;EACA,IAAIhB,MAAM,CAACiB,KAAK,CAAC,KAAK,IAAI,EAAE;IAC1BD,CAAC,CAACI,KAAK,GAAGH,KAAK,CAACW,OAAO,CAAC,CAAC;IACzB,OAAOZ,CAAC;EACV;EACA;EACA,IAAIf,OAAO,CAACgB,KAAK,CAAC,KAAK,IAAI,EAAE;IAC3BD,CAAC,GAAGb,UAAU,CAACa,CAAC,EAAEC,KAAK,EAAEC,KAAK,CAAC;IAC/B,OAAOF,CAAC;EACV;EACA;EACA,IAAIjB,QAAQ,CAACkB,KAAK,CAAC,KAAK,IAAI,EAAE;IAC5B;IACA,IAAIA,KAAK,CAACG,KAAK,EAAE;MACfJ,CAAC,CAACI,KAAK,GAAGH,KAAK,CAACG,KAAK;MACrBJ,CAAC,CAACa,EAAE,GAAGZ,KAAK,CAACY,EAAE;MACf,OAAOb,CAAC;IACV;IACAA,CAAC,GAAGZ,WAAW,CAACY,CAAC,EAAEC,KAAK,EAAEC,KAAK,CAAC;IAChC,OAAOF,CAAC;EACV;EACA;EACA,IAAI,OAAOC,KAAK,KAAK,QAAQ,EAAE;IAC7B,OAAOD,CAAC;EACV;EACA;EACAC,KAAK,GAAGV,SAAS,CAACU,KAAK,CAAC;EACxB;EACA,IAAIX,UAAU,CAACwB,cAAc,CAACb,KAAK,CAAC,KAAK,IAAI,EAAE;IAC7CD,CAAC,GAAGV,UAAU,CAACW,KAAK,CAAC,CAACD,CAAC,CAAC;IACxB,OAAOA,CAAC;EACV;EACA;EACA,OAAOR,WAAW,CAACQ,CAAC,EAAEC,KAAK,CAAC;AAC9B,CAAC;AACD,eAAeF,UAAU"},"metadata":{},"sourceType":"module","externalDependencies":[]}